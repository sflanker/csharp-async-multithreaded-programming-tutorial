# Thread.Interrupt

Once a thread has been started it will be in the [`Running` state](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.threadstate?view=net-8.0) and continue to execute in parallel with other threads until its entry point function returns or the thread is interrupted. It is possible to block until another thread completes using the [Thread.Join](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.join?view=net-8.0) method. There is no reliable mechanism to terminate a running thread at an arbitrary point in its execution. It is possible to interrupt a running thread and potentially stop its execution using [Thread.Interrupt](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.interrupt?view=net-8.0). However, calling `Interrupt` will only affect a thread when it next enters or is in a [WaitSleepJoin](https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadstate?view=net-8.0#system-threading-threadstate-waitsleepjoin) state. This occurs when a thread explicitly calls `Thread.Sleep` or becomes blocked waiting for a synchronization primitive. A thread that performs IO or synchronization operations is likely to become in this state, however I thread that is purely performing CPU bound work may never actually enter this state. Additionally it is possible for code to catch and handle the [ThreadInterruptedException](https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadinterruptedexception?view=net-8.0) and continue execution, so calling `Iterrupt` does not actually gaurantee that a thread will exit in a timely fashion.

> There used the be a [Thread.Abort](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.abort?view=net-8.0) method, but it is now deprecated and will throw `PlatformNotSupportedException` if it is called and have no effect on the thread.